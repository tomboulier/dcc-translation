// Algebre en dimension n
// Partie II : 
//
// LD Nov 94 : creation

// (c) Copyright TIMC 1993

#define TRUE 1
#define FALSE 0

#include <cstdlib>
#include <cstdio>
#include <sparsecolmat.h>
#include <cmath>
#include <typescalaire.h>
#include <alp.h>
// #include <fstream>
//
// ========
//  SparseColMat
// ========

using namespace std;



void SparseColMat::Allocate()
// Allocate *a, *ia with dimension dim1*n
{
  a=new Scalaire[dim1*(n)];  // matrix entries
  ja=new int[dim1*(n+1)]; // *ja(i,0) is the number of nonzero entries 
                           // in the line i
                          //  *ja(i,k) are the j index of the nonzero entries
  lina=(new Scalaire*[dim1+1]); //
  linja=(new int*[dim1+1]);
}
//
// Constructors and destructors
// =============================
//
SparseColMat::SparseColMat(const int n1,const int n2,const int width)
     // allocate  a sparse matrix of true dimensions dim1 x dim2   
     // and of real dimension dim1*n
     //
{
  int i;
  dim1=n1;dim2=n2;n=width;
  Allocate();
  for (i=1;i<=dim1;i++)
    {
      lina[i]=&(a[(i-1)*n]);
      linja[i]=&(ja[(i-1)*(n+1)]);
      linja[i][0]=0;
    }
}

//virtual SparseColMat::~SparseColMat()
SparseColMat::~SparseColMat()
     // free a SparseColMat
{
  delete [] a;
  delete [] ja;
  delete [] lina;
  delete [] linja;
//  delete [] &(lina[1]);
//  delete [] &(linja[1]);
}

//
// structure access
// ===============
//
// inline Scalaire & operator () (const int i,const int j)
// Acces to *a(i,j) ( i must be >=1 and <=dim1,
//                    j must be >=1 and <=n
//          Scalaire & operator () (const int i,const int j);
// Acces to *a(i,j) ( i must be >=1 and <=dim1,
void SparseColMat::Set(const Scalaire x,const int i,const int j) 
     //  i must be >=1 and <=dim1, j must be >=1 and <=dim2
     // A(i,j)=x
     // i.e. let k be the first integer
     // such that *ja(i,k)=0 then
     //         *ja(i,k)=j and *a(i,k)=x
     //  (if *ja(i,k) <>0 until k=n then ERROR and STOP.
{
  if(linja[i][0]==n)
    {
      cout << " ERR in Set : line " << i << " is full !!! " << endl;
      exit(1);
    }
  else
    {
      linja[i][0]++;
      linja[i][linja[i][0]]=j;
      lina[i][linja[i][0]]=x;
    }
}

Scalaire SparseColMat::Get(const int i,const int j)
     // return A(i,j)
     // i.e., *a(i,k) if \exists k such that *ja(i,k)=j
     //       0  otherwise
{ 
  int k,kj,stop;
  stop=0;
  kj=0;
  for(k=1;(k<=n) && (stop==0);k++) 
    {
      if(linja[i][k]==j)
	{
	  kj=k;
	  stop=1;
	}
    }
  if(kj==0)
    return 0.;
  else
    return lina[i][kj];
}

int SparseColMat::JA(const int i,const int k)
     // return *ja(i,k) 
{
return linja[i][k];
}

int SparseColMat::N()// Dimension 
{
return n;
}

int SparseColMat::DIM1 ()// first dimension
{
return dim1;
}
	
int SparseColMat::DIM2 ()// second dimension
{
return dim2;
}	
//
// Initialisations
// ===============
//
void SparseColMat::Nul()  // nul. matrix [both *a (0,0,...,0) and *ja]
{
  int i,k;
  for (i=1;i<=dim1;i++)
    {
      linja[i][0]=0;
      for (k=1;k<=n;k++)
	{
	  lina[i][k]=0.;
	  linja[i][k]=0;
	}
    }
}

void SparseColMat::Indentity()
     //  *a (1,1,...,1,1,1,...,1) 
     //  *ja(i,1)=i and *ja(i,j)=0 if i<>1
{
  int i;
  Nul();
   for (i=1;i<=dim1;i++)
    {
      lina[i][1]=1.;
      linja[i][0]=1;
      linja[i][1]=i;
    }
}

//
// Operators
// ==========
//

void ProdSparseColMatVector(SparseColMat *a,Vector *x,Vector *y)
// y <- A x
{
  int i,k;
  Scalaire sum;
  for(i=1;i<=a->DIM1();i++)
    {
      sum=0.;
//      cout  << endl;
//      cout << " i " << i << endl;
      for(k=1;k<=a->JA(i,0);k++)
	{
//      cout << " ja " << a->JA(i,k) << endl;
	sum=sum+(*a)(i,k)*(*x)(a->JA(i,k));
      }
      (*y)(i)=sum;
    }
}

void ProdtransSparseColMatVector(SparseColMat *a,Vector *x,Vector *y)
// y <- A^t x
{
  int i,k;

  for(k=1;k<=a->DIM2();k++)
      (*y)(k)=0.;
  for(i=1;i<=a->DIM1();i++)
    {
//      cout << " line " << i << " number of <> 0 el : "<< a->JA(i,0) << endl;
//      cout << " indirection ";
//      for(k=1;k<=a->JA(i,0);k++)
//	cout << a->JA(i,k) << " ";
//      cout << endl;
      for(k=1;k<=a->JA(i,0);k++)
	(*y)(a->JA(i,k))=(*y)(a->JA(i,k))+(*a)(i,k)*(*x)(i);
    }
// a->JA(i,k)=J Y(J)=Y(J)+A(i,J)X(i)
}

void SLSCG(SparseColMat *a,Vector *x,Vector *b,
	   Scalaire arret,int itermin,int itermax,int & iter,
	   Vector *r,int verbose)
     // Sparse Least Squares Cojugate Gradient.
     // allows us to solve a sparse linear least squares 
     // Min_{x} || A x - b ||
     //
     // *a is a SparseColMat of dimension DIM1 x DIM2
     // *x is a Vector of dimension DIM2
     // *b is a Vector of dimension DIM1
     // *r,is a  vector of dimension DIM2 (residual A^t A x - A^t b )
     // arret : STOP criterion
     //         if ||*r(k)|| <= arret or if ||*r(k)||/||*r(0)||
     //           where *r(k) is the residual at iteration k.
     // verbose ==1 then the program is verbose...
{
  Vector *d, *atad, *atb,*vinter;

  Scalaire rkrk,rzrz, ri, norme, alpha, beta;
  int i,n;
  int fini; /* 0=false, 1=true */

  n=a->DIM2();
  cout <<"  DIMENSION n "<< n <<endl;

  d=new Vector(n);
  atad=new Vector(n);
  atb=new Vector(n);
  vinter=new Vector(a->DIM1());

// atb = A^t b
  ProdtransSparseColMatVector(a,b,atb);

  iter=0;
  fini=0;

// r = A^t A a - A^t b
  ProdSparseColMatVector(a,x,vinter);
  ProdtransSparseColMatVector(a,vinter,r);
  for(i=1;i<=n;i++)
    (*r)(i)=(*r)(i)-(*atb)(i);
// d = -r; rkrk=||r||^2
  rkrk=(double)0.;
  for(i=1;i<=n;i++)
    {
      ri=(*r)(i);
      (*d)(i)=-ri;
      rkrk=rkrk+ ri * ri;
    }
  if((rkrk/n)==0) fini=TRUE;
  if(verbose) cout << " Energie du residu (rkrk/n) : "<< rkrk/n << endl;
  rzrz=rkrk;

  while(fini==FALSE)
    {
      iter=iter+1;
      /* matadk */
      ProdSparseColMatVector(a,d,vinter);
      ProdtransSparseColMatVector(a,vinter,atad);
      /* ak=rktrk/dktadk */
      norme=(Scalaire) 0.;
      /* <ad,d> */
      for(i=1;i<=n;i++)
        {
          norme=norme + (*d)(i) * (*atad)(i);
        }
      if(norme==0.)
        {
          fini=TRUE;
          return;
        }
      else
        {
          alpha=rkrk/norme;
        }
      /* xk+1=xk+akdk */
      /*      x(i)=x(i)+alpha*d(i); */
      for(i=1;i<=n;i++)
        (*x)(i)=(*x)(i) + alpha * (*d)(i);
      /* rk+1=rk+akadk */
      /*      r(i)=r(i)+alpha*ad(i); */
      for(i=1;i<=n;i++)
        (*r)(i)=(*r)(i) + alpha * (*atad)(i);
      
      /* bk=rk+1trk+1/rkrk */
      /* norme=norme+r(i)**2 */
      norme=(Scalaire) 0.0;
      for(i=1;i<=n;i++)
	{
	  ri = (*r)(i);
	  norme=norme + ri * ri ;
	}
      beta=norme/rkrk;
      /* remise a jour de rkrk */
      rkrk=norme;
      /* dk+1=-rk+1+bk dk */
      /* d(i)=-r(i)+beta*d(i) */
      for(i=1;i<=n;i++)
        (*d)(i) = -(*r)(i)+ beta * (*d)(i) ;
      if((rkrk/n)<=(arret*arret))fini=TRUE;
      if((rkrk/rzrz)<=arret)fini=TRUE;
      if(iter<itermin)fini=FALSE;
      if(iter>=itermax)fini=TRUE;
      if(verbose) cout << " iteration no "<< iter;
      if(verbose) cout << " Energie du residu (rkrk/n) : "<< rkrk/n << endl;
    }
  delete d;
  delete atad;
  delete atb;
  delete vinter;
}

// =========================================================== //

void SLSCGreg3d(SparseColMat *a,Vector *x,Vector *b, 
		int dim1, int dim2, int dim3, Scalaire tau,
                int *out, int proj,
		Scalaire arret,int itermin,int itermax,int & iter,
		Vector *r,int verbose)
     // Sparse Least Squares Conjugate Gradient with Regularisation
     // allows us to solve a sparse linear least squares 
     // Min_{x} || A P x - b || +tau x^t PDP x
     // where D is the 3d Laplacian discretisation
     // x is suppose to be a 3D discretisation stored in the following way:
     // x(i*dim2*dim3+j*dim3+k)=x(i,j,k)
     // Dx=6x(i,j,k)-(x(i+1,j,k)+x(i-1,j,k)+ .....)
     // P is a projector onto support information 
     //       (equal to Identity if noproj=1)
     //
     // *a is a SparseColMat of dimension DIM1 x DIM2
     // *x is a Vector of dimension DIM2
     // *out is an integer array of dimension DIM2 for support information 
     //     introduction: if proj is equal to 0 then *out is suppose 
     //     to be zero. Else out[i-1]=1 means that (*x)(i-1) is nul
     //            (*out) is the complementary of the projector P
     // *b is a Vector of dimension DIM1
     // *r,is a  vector of dimension DIM2 [residual (A^t A +tau D)x - A^t b ]
     // arret : STOP criterion
     //         if ||*r(k)|| <= arret or if ||*r(k)||/||*r(0)||
     //           where *r(k) is the residual at iteration k.
     // verbose ==1 then the program is verbose...
{
  Vector *d, *atad, *atb,*vinter;

  Scalaire rkrk,rzrz, ri, norme, alpha, beta;
  int i,n;
  int fini; /* 0=false, 1=true */

  n=a->DIM2();
  cout <<"  DIMENSION n "<< n <<endl;
  if( (dim1*dim2*dim3) != n)
    {
      cout << " Err in SLSCGreg3d dim1,dim2,dim3: " << endl;
      cout << dim1 << " "  << dim2 << " " << dim2 << endl;
      exit(1);
    }

  d=new Vector(n);
  atad=new Vector(n);
  atb=new Vector(n);
  vinter=new Vector(a->DIM1());

// atb = A^t b
  ProdtransSparseColMatVector(a,b,atb);
  if(proj)
    {
      for(i=1;i<=n;i++)
	if(out[i-1]) (*atb)(i)=0;
    }
      
// 
  iter=0;
  fini=0;

// r = P(A^t A+tau D)P x - P A^t b
  if(proj)
    {
      for(i=1;i<=n;i++)
	if(out[i-1]) (*x)(i)=0;
    }
      
  ProdSparseColMatVector(a,x,vinter);
  ProdtransSparseColMatVector(a,vinter,r);
  AddLapla3D(x,dim1,dim2,dim3, tau, r);
  if(proj)
    {
      for(i=1;i<=n;i++)
	if(out[i-1]) (*r)(i)=0;
    }
      

  for(i=1;i<=n;i++)
    (*r)(i)=(*r)(i)-(*atb)(i);
// d = -r; rkrk=||r||^2
  rkrk=(double)0.;
  for(i=1;i<=n;i++)
    {
      ri=(*r)(i);
      (*d)(i)=-ri;
      rkrk=rkrk+ ri * ri;
    }
  if((rkrk/n)==0) fini=TRUE;
  if(verbose) cout << " Energie du residu (rkrk/n) : "<< rkrk/n << endl;
  rzrz=rkrk;

  while(fini==FALSE)
    {
      iter=iter+1;
      /* matadk */
      if(proj)
	{
	  for(i=1;i<=n;i++)
	    if(out[i-1]) (*d)(i)=0;
	}
      ProdSparseColMatVector(a,d,vinter);
      ProdtransSparseColMatVector(a,vinter,atad);
      AddLapla3D(d,dim1,dim2,dim3, tau, atad);
      if(proj)
	{
	  for(i=1;i<=n;i++)
	    if(out[i-1]) (*atad)(i)=0;
	}
      /* ak=rktrk/dktadk */
      norme=(Scalaire) 0.;
      /* <ad,d> */
      for(i=1;i<=n;i++)
        {
          norme=norme + (*d)(i) * (*atad)(i);
        }
      if(norme==0.)
        {
          fini=TRUE;
          return;
        }
      else
        {
          alpha=rkrk/norme;
        }
      /* xk+1=xk+akdk */
      /*      x(i)=x(i)+alpha*d(i); */
      for(i=1;i<=n;i++)
        (*x)(i)=(*x)(i) + alpha * (*d)(i);
      /* rk+1=rk+akadk */
      /*      r(i)=r(i)+alpha*ad(i); */
      for(i=1;i<=n;i++)
        (*r)(i)=(*r)(i) + alpha * (*atad)(i);
      
      /* bk=rk+1trk+1/rkrk */
      /* norme=norme+r(i)**2 */
      norme=(Scalaire) 0.0;
      for(i=1;i<=n;i++)
	{
	  ri = (*r)(i);
	  norme=norme + ri * ri ;
	}
      beta=norme/rkrk;
      /* remise a jour de rkrk */
      rkrk=norme;
      /* dk+1=-rk+1+bk dk */
      /* d(i)=-r(i)+beta*d(i) */
      for(i=1;i<=n;i++)
        (*d)(i) = -(*r)(i)+ beta * (*d)(i) ;
      if((rkrk/n)<=(arret*arret))fini=TRUE;
      if((rkrk/rzrz)<=arret)fini=TRUE;
      if(iter<itermin)fini=FALSE;
      if(iter>=itermax)fini=TRUE;
      if(verbose) cout << " iteration no "<< iter;
      if(verbose) cout << " Energie du residu (rkrk/n) : "<< rkrk/n << endl;
    }
  delete d;
  delete atad;
  delete atb;
  delete vinter;
}



void AddLapla3D(Vector *x, int dim1,int dim2,int dim3, Scalaire tau,Vector *y)
//  *y=*y+tau D *x
{
  int i,j,k;
  for(i=1;i<dim1-1;i++)
    for(j=1;j<dim2-1;j++)
      for(k=1;k<dim3-1;k++)
        {
	  (*y)(i*dim2*dim3+j*dim3+k+1)=(*y)(i*dim2*dim3+j*dim3+k+1)
	    + tau * (6* (*x)(i*dim2*dim3+j*dim3+k+1)
		     - (*x)((i-1)*dim2*dim3+j*dim3+k+1)
		     - (*x)((i+1)*dim2*dim3+j*dim3+k+1)
		     - (*x)(i*dim2*dim3+(j-1)*dim3+k+1)
		     - (*x)(i*dim2*dim3+(j+1)*dim3+k+1)
		     - (*x)(i*dim2*dim3+j*dim3+k-1+1)
		     - (*x)(i*dim2*dim3+j*dim3+k+1+1) );
	}

  for(j=0;j<dim2;j++)
    for(k=0;k<dim3;k++)
      {
	(*y)(j*dim3+k+1)=(*y)(j*dim3+k+1)
	  + tau * (*x)(j*dim3+k+1);
	(*y)((dim1-1)*dim2*dim3+j*dim3+k+1)=(*y)((dim1-1)*dim2*dim3+j*dim3+k+1)
	  + tau * (*x)((dim1-1)*dim2*dim3+j*dim3+k+1);
      }

  for(i=0;i<dim1;i++)
    for(k=0;k<dim3;k++)
      {
	(*y)(i*dim2*dim3+k+1)=(*y)(i*dim2*dim3+k+1)
	  + tau *  (*x)(i*dim2*dim3+k+1);
	(*y)(i*dim2*dim3+(dim2-1)*dim3+k+1)=(*y)(i*dim2*dim3+(dim2-1)*dim3+k+1)
	  + tau *  (*x)(i*dim2*dim3+(dim2-1)*dim3+k+1);
      }

  for(i=0;i<dim1;i++)
    for(j=0;j<dim2;j++)
      {
	(*y)(i*dim2*dim3+j*dim3+1)=(*y)(i*dim2*dim3+j*dim3+1)
	  + tau *  (*x)(i*dim2*dim3+j*dim3+1);
	(*y)(i*dim2*dim3+j*dim3+(dim3-1)+1)=(*y)(i*dim2*dim3+j*dim3+(dim3-1)+1)
	  + tau *  (*x)(i*dim2*dim3+j*dim3+(dim3-1)+1);
      }


}

//========================================================================
void SLSCGreg3dpg(SparseColMat *a,Vector **x,Vector **b, 
		int dim1, int dim2, int dim3, Scalaire tau,
                int *out, int proj,
		Scalaire arret,int itermin,int itermax,int & iter,
		Vector **r,int verbose)
     // FOR PARALLEL GEOMETRIES !!!
     // Sparse Least Squares Conjugate Gradient with Regularisation
     // allows us to solve a sparse linear least squares 
     // Min_{x} || A P x - b || +tau x^t PDP x
     // where D is the 3d Laplacian discretisation
     // x is suppose to be a 3D discretisation stored in the following way:
     // (*(x[j]))(k*dim1+i+1)=x(i,j,k)
     // Dx=6x(i,j,k)-(x(i+1,j,k)+x(i-1,j,k)+ .....)
     // P is a projector onto support information 
     //       (equal to Identity if noproj=1)
     //
     // *a is a SparseColMat of dimension DIM1A x DIM2A
     // **x are dim1  Vectors of dimension DIM2A=dim3*dim2
     // *out is an integer array of dimension dim1*DIM2A (dim1*dim2*dim3)
     //     for support  information 
     //     introduction: if proj is equal to 0 then *out is suppose 
     //     to be zero. Else out[j*dim2+i-1]=1 means that (*(x[j]))(i-1) is nul
     //            (*out) is the complementary of the projector P
     // *b are dim1  Vector of dimension DIM1A
     // *r are dim1  Vector of dimension DIM1A [residual (A^t A +tau D)x - A^t b ]
     // arret : STOP criterion
     //         if ||*r(k)|| <= arret or if ||*r(k)||/||*r(0)||
     //           where *r(k) is the residual at iteration k.
     // verbose ==1 then the program is verbose...
{
  Scalaire rkrk,rzrz, ri, norme, alpha, beta;
  int i,j,n;
  int fini; /* 0=false, 1=true */

  n=a->DIM2();
  cout <<"  DIMENSION n "<< n <<endl;
  if( (dim3*dim2) != n)
    {
      cout << " Err in SLSCGreg3d dim1,dim2,dim3: " << endl;
      cout << dim1 << " "  << dim2 << " " << dim2 << endl;
      exit(1);
    }

  Vector **d, **atad, **atb,**vinter;
  d = new Vector* [dim1];
  atad= new Vector* [dim1];
  atb= new Vector* [dim1];
  vinter= new Vector* [dim1];
  for(j=0;j<dim1;j++) {
    d[j]= new Vector(n);
    atad[j]=new Vector(n);
    atb[j]=new Vector(n);
    vinter[j]=new Vector(a->DIM1());
  }

// atb = A^t b
  for(j=0;j<dim1;j++) 
    ProdtransSparseColMatVector(a,b[j],atb[j]);
  if(proj)
    {
        for(j=0;j<dim1;j++) 
	  for(i=1;i<=n;i++)
	    if(out[j*n+i-1]) (*(atb[j]))(i)=0;
    }
      
// 
  iter=0;
  fini=0;

// r = P(A^t A+tau D)P x - P A^t b
  if(proj)
    {
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  if(out[j*n+i-1]) (*(x[j]))(i)=0;
    }
      
  for(j=0;j<dim1;j++) 
    ProdSparseColMatVector(a,x[j],vinter[j]);
  for(j=0;j<dim1;j++) 
    ProdtransSparseColMatVector(a,vinter[j],r[j]);
  AddLapla3Dgp(x,dim1,dim2,dim3, tau,r);
  if(proj)
    {
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  if(out[j*n+i-1]) (*(r[j]))(i)=0;
    }
      

  for(j=0;j<dim1;j++) 
    for(i=1;i<=n;i++)
      (*(r[j]))(i)=(*(r[j]))(i)-(*(atb[j]))(i);
// d = -r; rkrk=||r||^2
  rkrk=(double)0.;
  for(j=0;j<dim1;j++) 
    for(i=1;i<=n;i++){
      ri=(*(r[j]))(i);
      (*(d[j]))(i)=-ri;
      rkrk=rkrk+ ri * ri;
    }
  if((rkrk/(n*dim1))==0) fini=TRUE;
  if(verbose) cout << " Energie du residu (rkrk/(n*dim1)) : "<< rkrk/(n*dim1) << endl;
  if(verbose) std::cout << " n : "<< n << endl;
  if(verbose) std::cout << " dim1 : "<< dim1 << endl;
  rzrz=rkrk;

  while(fini==FALSE)
    {
      iter=iter+1;
      /* matadk */
      if(proj)
	{
	  for(j=0;j<dim1;j++) 
	    for(i=1;i<=n;i++)
	      if(out[j*n+i-1]) (*(d[j]))(i)=0;
	}
      for(j=0;j<dim1;j++) 
	ProdSparseColMatVector(a,d[j],vinter[j]);
      for(j=0;j<dim1;j++) 
	ProdtransSparseColMatVector(a,vinter[j],atad[j]);
      AddLapla3Dgp(d,dim1,dim2,dim3, tau, atad);
      if(proj)
	{
	  for(j=0;j<dim1;j++) 
	    for(i=1;i<=n;i++)
	      if(out[j*n+i-1]) (*(atad[j]))(i)=0;
	}
      /* ak=rktrk/dktadk */
      norme=(Scalaire) 0.;
      /* <ad,d> */
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  {
	    norme=norme + (*(d[j]))(i) * (*(atad[j]))(i);
	  }
      if(norme==0.)
        {
          fini=TRUE;
          return;
        }
      else
        {
          alpha=rkrk/norme;
        }
      /* xk+1=xk+akdk */
      /*      x(i)=x(i)+alpha*d(i); */
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  (*(x[j]))(i)=(*(x[j]))(i) + alpha * (*(d[j]))(i);
      /* rk+1=rk+akadk */
      /*      r(i)=r(i)+alpha*ad(i); */
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  (*(r[j]))(i)=(*(r[j]))(i) + alpha * (*(atad[j]))(i);
      
      /* bk=rk+1trk+1/rkrk */
      /* norme=norme+r(i)**2 */
      norme=(Scalaire) 0.0;
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++){
	  ri = (*(r[j]))(i);
	  norme=norme + ri * ri ;
	}
      beta=norme/rkrk;
      /* remise a jour de rkrk */
      rkrk=norme;
      /* dk+1=-rk+1+bk dk */
      /* d(i)=-r(i)+beta*d(i) */
      for(j=0;j<dim1;j++) 
	for(i=1;i<=n;i++)
	  (*(d[j]))(i) = -(*(r[j]))(i)+ beta * (*(d[j]))(i) ;
      if((rkrk/(n*dim1))<=(arret*arret))fini=TRUE;
      if((rkrk/rzrz)<=arret)fini=TRUE;
      if(iter<itermin)fini=FALSE;
      if(iter>=itermax)fini=TRUE;
      if(verbose) cout << " iteration no "<< iter;
      if(verbose) cout << " Energie du residu (rkrk/(n*dim1)) : "
	<< rkrk/(n*dim1) << endl;
    }
  for(j=0;j<dim1;j++) {
    delete d[j];
    delete atad[j];
    delete atb[j];
    delete vinter[j];
  }
  delete [] d;
  delete [] atad;
  delete [] atb;
  delete [] vinter;
}


void AddLapla3Dgp(Vector **x, int dim1,int dim2,int dim3, 
		Scalaire tau,Vector **y)
     // FOR PARALLEL GEOMETRIES !!!
     //  *y=*y+tau D *x
{
  int i,j,k;
    for(i=1;i<dim1-1;i++)
    for(j=1;j<dim2-1;j++)
      for(k=1;k<dim3-1;k++)
        {
	  (*(y[i]))(j*dim3+k+1)=(*(y[i]))(j*dim3+k+1)
	   + tau * (6* (*(x[i]))(j*dim3+k+1)
		    - (*(x[i-1]))(j*dim3+k+1)
		    - (*(x[i+1]))(+j*dim3+k+1)
		     - (*(x[i]))((j-1)*dim3+k+1)
		     - (*(x[i]))((j+1)*dim3+k+1)
		     - (*(x[i]))(j*dim3+k-1+1)
		     - (*(x[i]))(+j*dim3+k+1+1) );
	}

  for(j=0;j<dim2;j++)
    for(k=0;k<dim3;k++)
      {
	(*(y[0]))(j*dim3+k+1)=(*(y[0]))(j*dim3+k+1)
	  + tau * (*(x[0]))(j*dim3+k+1);
	(*(y[dim1-1]))(j*dim3+k+1)=(*(y[dim1-1]))(j*dim3+k+1)
	  + tau * (*(x[dim1-1]))(j*dim3+k+1);
      }

  for(i=0;i<dim1;i++)
    for(k=0;k<dim3;k++)
      {
	(*(y[i]))(k+1)=(*(y[i]))(k+1)
	  + tau *  (*(x[i]))(k+1);
	(*(y[i]))((dim2-1)*dim3+k+1)=(*(y[i]))((dim2-1)*dim3+k+1)
	  + tau *  (*(x[i]))((dim2-1)*dim3+k+1);
      }

  for(i=0;i<dim1;i++)
    for(j=0;j<dim2;j++)
      {
	(*(y[i]))(j*dim3+1)=(*(y[i]))(j*dim3+1)
	  + tau *  (*(x[i]))(j*dim3+1);
	(*(y[i]))(j*dim3+(dim3-1)+1)=(*(y[i]))(j*dim3+(dim3-1)+1)
	  + tau *  (*(x[i]))(j*dim3+(dim3-1)+1);
      }
}
