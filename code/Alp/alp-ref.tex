% Carte de reference de la librairie ALP
% EB Juin 95

\documentclass[a4paper,10pt]{article}
\usepackage{ifthen}

\oddsidemargin=0cm
\topmargin=-1cm
\textwidth=16cm
\textheight=24cm
\linewidth=\textwidth
\columnsep=10mm
\columnseprule=0.1mm

\newsavebox{\foncbox}
\newlength{\fonclen}

\begin{document}

\newcommand{\fonc}[2]{\noindent
	{\savebox{\foncbox}[\width][t]{\raggedright
		{\sffamily\bfseries\footnotesize #1}}
	\settowidth{\fonclen}{\usebox{\foncbox}}
	\usebox{\foncbox}
	\ifthenelse{\lengthtest{\fonclen > 0.57\linewidth }}
		{\newline\rule{5mm}{0mm}\hfill}
		{\dotfill}
	\parbox[t]{0.4\linewidth}
		{\sffamily\mdseries\footnotesize #2}
	}\par}
\newcommand{\this}{\textrm{this}}

\begin{center}
\noindent{\sffamily\bfseries\huge ALP library reference card}\\ \vspace{5mm}
{\sffamily\large Eric Bainville -- June 1995}
\end{center}

\section{Class Vector}

% =======================================================
\subsection{Constructors and destructor}
% =======================================================

\fonc{Vector::Vector(int~$n$)}
	{Constructs a real vector of dimension $n$ (not initialized)}
\fonc{Vector::Vector(double~$x_1$, double~$x_2$)}
	{Constructs a real vector of dimension $2$ initialized with $(x_1,x_2)$}
\fonc{Vector::Vector(double~$x_1$, double~$x_2$, double~$x_3$)}
	{Constructs a real vector of dimension $3$ initialized with $(x_1,x_2,x_3)$}
\fonc{Vector::Vector(double~$x_1$, double~$x_2$, double~$x_3$, double~$x_4$)}
	{Constructs a real vector of dimension $3$ initialized with $(x_1,x_2,x_3,x_4)$}
\fonc{Vector::Vector(const~Vector\&~$u$)}
	{Constructs a real vector which is a copy of $u$}
\fonc{Vector::$\sim$Vector()}
	{Destroys a real vector}

% =======================================================
\subsection{Structure access}
% =======================================================

\fonc{void Vector::Zero()}
	{$\this_i \leftarrow 0$}
\fonc{void Vector::Set(double~$x_1$, double~$x_2$)}
	{$\this_i \leftarrow x_i$, $i=1 \ldots 2$}
\fonc{void Vector::Set(double~$x_1$, double~$x_2$, double~$x_3$)}
	{$\this_i \leftarrow x_i$, $i=1 \ldots 3$}
\fonc{void Vector::Set(double~$x_1$, double~$x_2$, double~$x_3$, double~$x_4$)}
	{$\this_i \leftarrow x_i$, $i=1 \ldots 4$}
\fonc{void Vector::Get(double\&~$x_1$, double\&~$x_2$)}
	{$x_i \leftarrow \this_i$, $i=1 \ldots 2$}
\fonc{void Vector::Get(double\&~$x_1$, double\&~$x_2$, double\&~$x_3$)}
	{$x_i \leftarrow \this_i$, $i=1 \ldots 3$}
\fonc{void Vector::Get(double\&~$x_1$, double\&~$x_2$, double\&~$x_3$, double\&~$x_4$)}
	{$x_i \leftarrow \this_i$, $i=1 \ldots 4$}
\fonc{double\& Vector::operator~()~(int~$i$)}
	{$\leftarrow$ reference to $\this_i$}
\fonc{double Vector::operator~()~(int~$i$)~const}
	{$\leftarrow \this_i$}
\fonc{int Vector::N()}
	{$\leftarrow$ dimension of $\this$}

% =======================================================
\subsection{Bounds operators}
% =======================================================

In the following functions, $i_0$ is the value of the index $i$
which optimizes the given criterion.

\begin{center}
\begin{tabular}{|c|c|} \hline
$\langle$Criterion$\rangle$ & Optimization \\ \hline
Min & min $u_i$ \\ \hline
Max & max $u_i$ \\ \hline
MinAbs & min $|u_i|$ \\ \hline
MaxAbs & max $|u_i|$ \\ \hline
\end{tabular}
\end{center}

\fonc{int $\langle$Criterion$\rangle$Index(const~Vector\&~$u$)}
	{$\leftarrow i_0$}
\fonc{double $\langle$Criterion$\rangle$(const~Vector\&~$u$)}
	{$\leftarrow u_{i_0}$}
\fonc{void $\langle$Criterion$\rangle$IndexAndValue(const~Vector\&~$u$,
	int\&~$i$, double\&~$x$)}
	{$(i,x) \leftarrow (i_0,u_{i_0})$}
\fonc{int Vector::$\langle$Criterion$\rangle$Index()~const}
	{$\leftarrow i_0$}
\fonc{double Vector::$\langle$Criterion$\rangle$()~const}
	{$\leftarrow \this_{i_0}$}
\fonc{void Vector::$\langle$Criterion$\rangle$IndexAndValue(int\&~$i$,
	double\&~$x$)~const}
	{$(i,x) \leftarrow (i_0,\this_{i_0})$}

% =======================================================
\subsection{Memory operators}
% =======================================================

\fonc{Vector\& operator = (const~Vector\&~$u$)}
	{$\this \leftarrow u$, returns a reference to $\this$}
\fonc{void Copy(const~Vector\&~$a$,Vector\&~$b$)}
	{$b \leftarrow a$}
\fonc{void Swap(Vector\&~$a$,Vector\&~$b$)}
	{$a \leftrightarrow b$}

% =======================================================
\subsection{Norms, distances and dot product operators}
% =======================================================

$\Vert a\Vert$ denotes the usual Euclidian norm of the vector $a$ :
$$\Vert a\Vert = \sqrt{\sum_i a_i^2}.$$

\fonc{double AbsSum(const Vector\& $a$)}
	{$\leftarrow \Sigma |a_i|$}
\fonc{double Sum(const Vector\& $a$)}
	{$\leftarrow \Sigma a_i$}
\fonc{double Norm2(const Vector\& $a$)}
	{$\leftarrow \Vert a\Vert^2$}
\fonc{double Norm(const Vector\& $a$)}
	{$\leftarrow \Vert a\Vert$}
\fonc{double Dist2(const Vector\& $a$,const Vector\& $b$)}
	{$\leftarrow \Vert a-b\Vert^2$}
\fonc{double Dist(const Vector\& $a$,const Vector\& $b$)}
	{$\leftarrow \Vert a-b\Vert$}
\fonc{double Dot(const Vector\& $u$,const Vector\& $v$)}
	{$\leftarrow \Sigma u_i v_i$}
\fonc{void Normalize(const Vector\& $u$,Vector\& $v$)}
	{$v \leftarrow u/\Vert u\Vert$}
\vspace{\baselineskip}
\fonc{double Vector::AbsSum() const}
	{$\leftarrow \Sigma |\this_i|$}
\fonc{double Vector::Sum() const}
	{$\leftarrow \Sigma \this_i$}
\fonc{double Vector::Norm2() const}
	{$\leftarrow \Vert \this\Vert^2$}
\fonc{double Vector::Norm() const}
	{$\leftarrow \Vert \this\Vert$}
\fonc{void Vector::Normalize()}
	{$\this \leftarrow \this / \Vert \this\Vert$}

% =======================================================
\subsection{Vector space operators}
% =======================================================

\fonc{void Mul(const double $k$,const Vector\& $u$,Vector\& $v$)}
	{$v \leftarrow k u$}
\fonc{void Div(const double $k$,const Vector\& $u$,Vector\& $v$)}
	{$v \leftarrow k^{-1} u$}
\fonc{void Add(const Vector\& $u$,const Vector\& $v$,Vector\& $w$)}
	{$w \leftarrow u+v$}
\fonc{void Sub(const Vector\& $u$,const Vector\& $v$,Vector\& $w$)}
	{$w \leftarrow u-v$}
\fonc{void Add(const Vector\& $u$,double $k$,const Vector\& $v$,Vector\& $w$)}
	{$w \leftarrow u+kv$}
\fonc{void Combine(double $k_1$, const Vector\& $u_1$,
	double $k_2$,const Vector\& $u_2$, Vector\& $v$)}
	{$v \leftarrow k_1 u_1 + k_2 u_2$}
\fonc{void Combine(double $k_1$,const Vector\& $u_1$,
			double $k_2$,const Vector\& $u_2$,
			double $k_3$,const Vector\& $u_3$,
			Vector\& $v$)}
	{$v \leftarrow k_1 u_1 + k_2 u_2 + k_3 u_3$}
\fonc{void Middle(const Vector\& $a$,const Vector\& $b$,Vector\& $m$)}
	{$m \leftarrow 0.5 ( a+b )$}
\fonc{void Barycenter(double $k_1$,const Vector\& $a_1$,
			double $k_2$,const Vector\& $a_2$,Vector\& $a$)}
	{$a \leftarrow (k_1+k_2)^{-1} (k_1 a_1 + k_2 a_2)$}
\fonc{void Barycenter(double $k_1$,const Vector\& $a_1$,
			double $k_2$,const Vector\& $a_2$,
			double $k_3$,const Vector\& $a_3$,Vector\& $a$)}
	{$a \leftarrow (k_1+k_2+k_3)^{-1} (k_1 a_1 + k_2 a_2 + k_3 a_3)$}
\vspace{\baselineskip}
\fonc{Vector\& Vector::operator += (const Vector\& $u$)}
	{$\this \leftarrow \this + u$, returns a reference to $\this$}
\fonc{Vector\& Vector::operator -= (const Vector\& $u$)}
	{$\this \leftarrow \this - u$, returns a reference to $\this$}
\fonc{Vector\& Vector::operator *= (double $k$)}
	{$\this \leftarrow k \this$, returns a reference to $\this$}
\fonc{Vector\& Vector::operator /= (double $k$)}
	{$\this \leftarrow k^{-1} \this$, returns a reference to $\this$}
\fonc{void Vector::Add(const Vector\& $u$)}
	{$\this \leftarrow \this + u$}
\fonc{void Vector::Sub(const Vector\& $u$)}
	{$\this \leftarrow \this - u$}
\fonc{void Vector::Mul(double $k$)}
	{$\this \leftarrow k \this$}
\fonc{void Vector::Div(double $k$)}
	{$\this \leftarrow k^{-1} \this$}
\fonc{void Vector::Add(double $k$,const Vector\& $u$)}
	{$\this \leftarrow \this + k u$}
\fonc{void Vector::Combine(double $k$,double $l$,const Vector\& $u$)}
	{$\this \leftarrow k \this + l u$}

% =======================================================
\subsection{Dimension specific operators}
% =======================================================

\fonc{double Det(const Vector\& $u$,const Vector\& $v$)}
	{$\leftarrow \det (u,v)$ with $\dim(u) = \dim(v) = 2$}
\fonc{double Det(const Vector\& $u$,const Vector\& $v$,const Vector\& $w$)}
	{$\leftarrow \det (u,v,v)$ with $\dim(u) = \dim(v) = \dim(w) = 3$}
\fonc{void Cross(const Vector\& $u$,const Vector\& $v$,Vector\& $w$)}
	{$w \leftarrow u \wedge v$ with $\dim(u) = \dim(v) = 3$}

\end{document}
